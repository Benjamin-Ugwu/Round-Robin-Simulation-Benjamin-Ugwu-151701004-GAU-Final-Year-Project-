/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package RoundRobinPackage;

import java.io.File;
import java.util.LinkedList;
import java.util.Scanner;
import javax.swing.JFrame;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author lenovo
 */



 class Job{//each process is a job class
    
    public int jobNumber;    // job ID
    public int arrivalTime;
        
    public int[] burst=new int[2];    
    public int[] start=new int[2];
    public boolean[] finished=new boolean[2];  // show if job is finished or not
    public int[] finish=new int[2];        // finish time
    public int[] remaining=new int[2];
    
    int whichBurst;
    public int io;  
    public boolean addToIO;
    public boolean returned;
    

    public Job()
    {
        this.jobNumber =0;
        arrivalTime =0; 
                
        this.burst[0] =0;
        this.burst[1] =0;
        
        start[0]=0;
        start[1]=0;
        
        finished[0] = false;
        finished[1] = false;
        
        finish[0] =0;     
        finish[1] =0; 
         
        remaining[0]=0;
        remaining[1]=0;
        
        whichBurst=0;
        this.io=0;
        addToIO=false;
        returned=false;
    }    
    
    public Job(int jobNumber , int arrive , int burst,int io,int burst2)
    {
        this.jobNumber=jobNumber;
        arrivalTime=arrive; 
                
        this.burst[0]=burst;
        this.burst[1]=burst2;
        
        start[0]=0;
        start[1]=0;
        
        finished[0] = false;
        finished[1] = false;
        
        finish[0] =0;     
        finish[1] =0; 
         
        remaining[0]=burst;
        remaining[1]=burst2;
        
        whichBurst=0;
        this.io=io;
        addToIO=false;
        returned=false;
    }    
 }



 class ReadFile { //get jobs from file    
        Scanner JobsFile;   
                
        int JobsCount=0;
        int[] QC=new int[2];//Q:quantumTime,C:contextSwitch
        
        LinkedList<Job> JobsList=new LinkedList<Job>();  
        
    public ReadFile(){    
                        try{
                                JobsFile=new Scanner(new File("C:\\Users\\lenovo\\Desktop\\Final Year\\Final Year 2nd Semester\\GPJ 2\\RoundRobin\\processFilePr.txt"));
                        }        
                        catch(Exception e){
                                System.out.println("File Not Found");
                        }

                        //Read number of Jobs, Quantum Time, Context switch time
                        //number of jobs will be calculated from the jobs read to avoid mistake of entering the wrong number of jobs in the file
                        QC[0]=JobsFile.nextInt();
                        QC[1]=JobsFile.nextInt();

                        //Read Jobs 
                        while(JobsFile.hasNextInt()){      
                        Job job=new Job(JobsFile.nextInt(),JobsFile.nextInt(),JobsFile.nextInt(),JobsFile.nextInt(),JobsFile.nextInt());//create a job object with each received job    
                        JobsList.add(job);  
                        JobsCount++;
                        }  
                JobsFile.close();  //close the file when reading is done
    }          
    
        //get  job list
        public LinkedList<Job> getJobList(){
               return JobsList;
        }
        
        //get number of Jobs, Quantum Time, Context switch time
        public int[] getQC(){
               return QC;
        }
    
}















public class RoundRobinJFrame extends javax.swing.JFrame {

    /**
     * Creates new form RoundRobinJFrame
     */
    public RoundRobinJFrame() {
     // this.setExtendedState(JFrame.MAXIMIZED_BOTH);//makes the JFrame full screen
        this.setTitle("ROUND ROBIN ALGORITHM SIMULATION (Time in Milliseconds) BY BENJAMIN OKWUDILI UGWU (151701004)");        
        initComponents();   
        readFileButton.setEnabled(true);
        runButton.setEnabled(false);
        stopButton.setEnabled(false);         
        restartButton.setEnabled(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTable3 = new javax.swing.JTable();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTable4 = new javax.swing.JTable();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        runButton = new javax.swing.JButton();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();
        numberOfJobsLabel = new javax.swing.JLabel();
        contextSwitchLabel = new javax.swing.JLabel();
        quantumLabel = new javax.swing.JLabel();
        restartButton = new javax.swing.JButton();
        readFileButton = new javax.swing.JButton();
        stopButton = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jobPoolTable = new javax.swing.JTable();
        jPanel3 = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        jLabel16 = new javax.swing.JLabel();
        jScrollPane5 = new javax.swing.JScrollPane();
        readyQLabel = new javax.swing.JLabel();
        jPanel4 = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        runningJobLabel = new javax.swing.JLabel();
        clockLabel = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();
        cpuStatusLabel = new javax.swing.JLabel();
        jPanel5 = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        averageWTLabel = new javax.swing.JLabel();
        averageTTLabel = new javax.swing.JLabel();
        jPanel6 = new javax.swing.JPanel();
        jLabel6 = new javax.swing.JLabel();
        inputOutputScrollPane = new javax.swing.JScrollPane();
        ioLabel = new javax.swing.JLabel();
        jPanel7 = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        jScrollPane6 = new javax.swing.JScrollPane();
        ganttChartLabel = new javax.swing.JLabel();

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane1.setViewportView(jTable1);

        jTable3.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane3.setViewportView(jTable3);

        jTable4.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane4.setViewportView(jTable4);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBackground(new java.awt.Color(204, 204, 204));

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(255, 0, 0));
        jLabel1.setText("DATA");

        runButton.setBackground(new java.awt.Color(0, 204, 51));
        runButton.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        runButton.setForeground(new java.awt.Color(0, 0, 204));
        runButton.setText("Run Algorithm");
        runButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runButtonActionPerformed(evt);
            }
        });

        jLabel12.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel12.setText("Quantum Time:");

        jLabel13.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel13.setText("Number of Jobs:");

        jLabel14.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel14.setText("Context Switch Time:");

        numberOfJobsLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        numberOfJobsLabel.setText("---");

        contextSwitchLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        contextSwitchLabel.setText("---");

        quantumLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        quantumLabel.setText("---");

        restartButton.setBackground(new java.awt.Color(0, 204, 51));
        restartButton.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        restartButton.setForeground(new java.awt.Color(0, 0, 204));
        restartButton.setText("Restart");
        restartButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                restartButtonActionPerformed(evt);
            }
        });

        readFileButton.setBackground(new java.awt.Color(0, 204, 51));
        readFileButton.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        readFileButton.setForeground(new java.awt.Color(0, 0, 204));
        readFileButton.setText("Read File");
        readFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                readFileButtonActionPerformed(evt);
            }
        });

        stopButton.setBackground(new java.awt.Color(0, 204, 51));
        stopButton.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        stopButton.setForeground(new java.awt.Color(0, 0, 204));
        stopButton.setText("Stop");
        stopButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(165, 165, 165)
                .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(101, 101, 101))
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel14, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel13, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGap(36, 36, 36))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(jLabel12, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGap(41, 41, 41)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(numberOfJobsLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(quantumLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(contextSwitchLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addComponent(readFileButton)))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(5, 5, 5)
                        .addComponent(runButton)
                        .addGap(14, 14, 14)
                        .addComponent(stopButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(restartButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(31, 31, 31))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(jLabel1)
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel13, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(numberOfJobsLabel))
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(9, 9, 9)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(quantumLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 18, Short.MAX_VALUE)
                            .addComponent(jLabel12, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(4, 4, 4)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel14, javax.swing.GroupLayout.DEFAULT_SIZE, 22, Short.MAX_VALUE)
                            .addComponent(contextSwitchLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 18, Short.MAX_VALUE)))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(readFileButton)))
                .addGap(37, 37, 37)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(runButton)
                    .addComponent(restartButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(stopButton))
                .addContainerGap())
        );

        jPanel2.setBackground(new java.awt.Color(204, 204, 204));

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel2.setForeground(new java.awt.Color(255, 0, 0));
        jLabel2.setText("JOB POOL");

        jobPoolTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "#Job", "Arrival", "Burst 1", "i/o", "Burst 2", "Start", "Remaining", "Finish", "Waiting", "Turnaround"
            }
        ));
        jScrollPane2.setViewportView(jobPoolTable);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(212, 212, 212)
                .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(148, 148, 148))
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 553, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(jLabel2)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                    .addGap(35, 35, 35)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 149, Short.MAX_VALUE)
                    .addContainerGap()))
        );

        jPanel3.setBackground(new java.awt.Color(204, 204, 204));

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel3.setForeground(new java.awt.Color(255, 0, 0));
        jLabel3.setText("READY QUEUE");

        jLabel16.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel16.setForeground(new java.awt.Color(255, 0, 0));
        jLabel16.setText("<---");

        readyQLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        readyQLabel.setForeground(new java.awt.Color(0, 0, 204));
        jScrollPane5.setViewportView(readyQLabel);

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addContainerGap(20, Short.MAX_VALUE)
                        .addComponent(jLabel16, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 214, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addGap(63, 63, 63)
                        .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addGap(63, 63, 63))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addComponent(jLabel3)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(jLabel16, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(28, 28, 28))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                        .addGap(7, 7, 7)
                        .addComponent(jScrollPane5)
                        .addContainerGap())))
        );

        jPanel4.setBackground(new java.awt.Color(204, 204, 204));

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel4.setForeground(new java.awt.Color(255, 0, 0));
        jLabel4.setText("CPU");

        jLabel8.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel8.setText("Running Job");

        jLabel9.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel9.setText("Time");

        runningJobLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        runningJobLabel.setText("---");

        clockLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        clockLabel.setText("---");
        clockLabel.setName(""); // NOI18N

        jLabel15.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel15.setText("Status");

        cpuStatusLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        cpuStatusLabel.setForeground(new java.awt.Color(0, 204, 51));
        cpuStatusLabel.setText("Idle");
        cpuStatusLabel.setName(""); // NOI18N

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                .addGap(121, 121, 121)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(103, 103, 103))
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addGap(16, 16, 16)
                        .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel4Layout.createSequentialGroup()
                                .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(jPanel4Layout.createSequentialGroup()
                                .addComponent(clockLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGap(57, 57, 57)
                                .addComponent(cpuStatusLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGap(18, 18, 18))))))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addComponent(jLabel8, javax.swing.GroupLayout.DEFAULT_SIZE, 96, Short.MAX_VALUE)
                        .addGap(121, 121, 121))
                    .addGroup(jPanel4Layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(runningJobLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(125, 125, 125)))
                .addComponent(jLabel15, javax.swing.GroupLayout.DEFAULT_SIZE, 52, Short.MAX_VALUE)
                .addGap(18, 18, 18))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel8, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel9, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel15, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(runningJobLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(clockLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(cpuStatusLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(17, 17, 17))
        );

        jPanel5.setBackground(new java.awt.Color(204, 204, 204));

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel5.setForeground(new java.awt.Color(255, 0, 0));
        jLabel5.setText("AVERAGES");

        jLabel10.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel10.setText("Waiting Time");

        jLabel11.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        jLabel11.setText("Turnaround Time");

        averageWTLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        averageWTLabel.setText("---");

        averageTTLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        averageTTLabel.setText("---");

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel5Layout.createSequentialGroup()
                .addGap(30, 30, 30)
                .addComponent(jLabel10, javax.swing.GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE)
                .addGap(55, 55, 55)
                .addComponent(jLabel11, javax.swing.GroupLayout.DEFAULT_SIZE, 131, Short.MAX_VALUE)
                .addGap(29, 29, 29))
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addGap(110, 110, 110)
                .addComponent(jLabel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addGap(53, 53, 53)
                .addComponent(averageWTLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(118, 118, 118)
                .addComponent(averageTTLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(92, 92, 92))
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addComponent(jLabel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel10, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel11, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(averageWTLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(averageTTLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(21, 21, 21))
        );

        jPanel6.setBackground(new java.awt.Color(204, 204, 204));

        jLabel6.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel6.setForeground(new java.awt.Color(255, 0, 0));
        jLabel6.setText("INPUT/OUTPUT");

        ioLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        ioLabel.setForeground(new java.awt.Color(0, 0, 204));
        inputOutputScrollPane.setViewportView(ioLabel);

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(630, 630, 630))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel6Layout.createSequentialGroup()
                        .addComponent(inputOutputScrollPane)
                        .addContainerGap())))
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(inputOutputScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 25, Short.MAX_VALUE)
                .addGap(18, 18, 18))
        );

        jPanel7.setBackground(new java.awt.Color(204, 204, 204));

        jLabel7.setFont(new java.awt.Font("Tahoma", 1, 24)); // NOI18N
        jLabel7.setForeground(new java.awt.Color(255, 0, 0));
        jLabel7.setText("GANTT CHART");

        ganttChartLabel.setBackground(new java.awt.Color(255, 255, 102));
        ganttChartLabel.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        ganttChartLabel.setForeground(new java.awt.Color(0, 0, 204));
        jScrollPane6.setViewportView(ganttChartLabel);

        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel7Layout.createSequentialGroup()
                        .addComponent(jLabel7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(763, 763, 763))
                    .addGroup(jPanel7Layout.createSequentialGroup()
                        .addComponent(jScrollPane6)
                        .addContainerGap())))
        );
        jPanel7Layout.setVerticalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addComponent(jLabel7, javax.swing.GroupLayout.DEFAULT_SIZE, 35, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 48, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jPanel7, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel6, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(10, 10, 10)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanel7, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>                        

    
            //parameters for running the process
           int quantumTime;           
           int contextSwitch;
           int quantumCount;
           int clock=0;
           int finishedJobs=0;//counts the number of jobs finished at each step
           boolean stopped=false;
              
           LinkedList<Job> processList=new LinkedList<Job>();//the processes to be run           
           LinkedList<Job> readyQueue=new LinkedList<Job>();//the jobs ready to be run   
           LinkedList<Job> ioQueue=new LinkedList<Job>();//the jobs in i/o 
           
           LinkedList<Job> finishedJobsList=new LinkedList<Job>();//the jobs that have finished running  
           Job currentJob=new Job();
                      
           String ganttIncrease="|"; //for gantt chart
           String showIO; //to show processes in i/o 
           String showReadyQ;//to show processes in ready queue
           
           void populateData(){
               //processList.clear();
            ReadFile list=new ReadFile();
            processList.addAll(list.getJobList());
           
           quantumTime=list.getQC()[0];
           contextSwitch=list.getQC()[1];
                   
           numberOfJobsLabel.setText(""+processList.size());
           quantumLabel.setText(""+quantumTime);
           contextSwitchLabel.setText(""+contextSwitch);
           
           
           
           //print the job data
                                DefaultTableModel model=(DefaultTableModel) jobPoolTable.getModel();                                 
                                Object rowData[]=new Object[10];
                                for(int k=0;k<processList.size();k++)
                                {
                                    rowData[0]=processList.get(k).jobNumber;
                                    rowData[1]=processList.get(k).arrivalTime;
                                    rowData[2]=processList.get(k).burst[0];
                                    //System.out.print(rowData[2]);
                                    rowData[3]=processList.get(k).io;
                                    rowData[4]=processList.get(k).burst[1];
                                    model.addRow(rowData);
                                
                                }
           
           }
           
    
    private void runButtonActionPerformed(java.awt.event.ActionEvent evt) {                                          
        // TODO add your handling code here:              
         
           
           
           Thread t=new Thread(){ //start a thread               
           
               
               public void run(){
                   
                
            ///start processing           
            runButton.setEnabled(false);
            stopButton.setEnabled(true);     
             
           for(clock=0;;clock++){ //clock ticking
                   //System.out.println("tick: "+clock);
                   //display clock on frame
                clockLabel.setText(""+clock);
                
                   for(Job jb:processList){//check if a new process arrived at this time unit
                        int ck=jb.arrivalTime; //if you use jb.arrivalTime directly, it returns the address not the value
                        if(ck==clock){
                            readyQueue.add(jb); //add arrived process to the ready queue                            
                        }
                   }                                                                                                     
                  
                   
                  //check if a process in i/o is ready to return
                  LinkedList<Job> ioQueueTemp=new LinkedList<Job>();
                  ioQueueTemp.clear();
                  ioQueueTemp.addAll(ioQueue);                  
                  for(Job ready:ioQueueTemp){
                        if(ready.finish[0]+ready.io==clock){ 
                            readyQueue.add(ready); //add ready to return Job to the end of ready queue
                            System.out.println(ready.jobNumber+"returned to ready queue");
                            ioQueue.remove(ready);//remove the job from i/o
                            System.out.println(ready.jobNumber+"removed from i/o");                              
                        }
                  }
                   
                   
                   
                   
                    if(readyQueue.isEmpty()==false || quantumCount!=quantumTime && quantumCount!=0){
                        //if no job is ready yet || current job is still processing && a job has been received;==0 will let it in even though ready queue is still empty
                        
                        if(quantumCount==quantumTime || quantumCount==0){//the "==0 part" is to allow picking of Job at the very first beginning
                            currentJob=readyQueue.getFirst();//take the first job in ready queue
                            runningJobLabel.setText(""+currentJob.jobNumber);
                            readyQueue.remove(0);//remove the current job from the ready queue
                            quantumCount=0;//reset quantum count to 0
                        }
                         
                        System.out.println("current job: "+currentJob.jobNumber);
                        
                        if(currentJob.burst[currentJob.whichBurst]==currentJob.remaining[currentJob.whichBurst]){//get the start time
                            currentJob.start[currentJob.whichBurst]=clock;
                        }
                                    
                        cpuStatusLabel.setText("Busy");
                        currentJob.remaining[currentJob.whichBurst]--;//process one burst time unit of it                        
                        quantumCount++;//increase the number of burst time unit processed for a job

                       
                        if(quantumCount==quantumTime && currentJob.remaining[currentJob.whichBurst]!=0){//quantum time reached but, burst not completed yet
                            readyQueue.add(currentJob);//add to the end of the ready queue 
                             //quantumCount is ==quantumTime at this point
                        
                        }else{//quantum time completed or NOT,  but burst completed(also takes care of when burst <quantum) 
                                if(currentJob.remaining[currentJob.whichBurst]==0){
                                    currentJob.finish[currentJob.whichBurst]=clock;//finish time
                                    currentJob.finished[currentJob.whichBurst]=true;
                                    
                                    if(currentJob.burst[1]>0){currentJob.whichBurst=1;}//move to the second burst if there is second burst(>0) since first burst is completed
                                    quantumCount=quantumTime;//make it equal to quantum time to allow for another job to be picked from ready queue (another job is picked when the current one has completed its burst time or finished)
                                    
                                    /////////////// 
                                    //adding to io
                                    if(currentJob.remaining[0]==0 && currentJob.io>0 && currentJob.addToIO==false){
                                        ioQueue.add(currentJob);
                                        currentJob.addToIO=true;
                                        System.out.println(currentJob.jobNumber+" added to i/o");    
                                    }
                          
                                    
                                }                        
                        }
                        
                        //when a job finishes
                        if(currentJob.remaining[0]==0 && currentJob.remaining[1]==0){
                            finishedJobsList.add(currentJob);
                            System.out.println(currentJob.jobNumber+" finished");                            
                        }
                        
                        
                                              
                        //ganttChart                        
                        ganttIncrease+=currentJob.jobNumber+"|";
                        ganttChartLabel.setText(ganttIncrease);//gantchart label area
                        
                        //inputOutput
                        showIO="";
                        if(ioQueue.isEmpty()==false){//if io queue is not empty
                            //showIO="{";
                            for(Job io:ioQueue){                        
                                showIO+=" {"+io.jobNumber+"} ";                           
                            }                        
                        }
                        ioLabel.setText(showIO);
                        
                        //show ready queue                        
                        showReadyQ="   ";
                        for(Job rq:readyQueue){                        
                            showReadyQ+="<<<"+rq.jobNumber;                            
                        }
                        readyQLabel.setText(showReadyQ);
                        
                        
                        
                        
                        //print updates on the table(find the current Job on the Table and update the data)
                                
                                DefaultTableModel model=(DefaultTableModel) jobPoolTable.getModel();                                 
                                
                                for(int k=0;k<processList.size();k++)
                                {
                                    if(processList.get(k).jobNumber==currentJob.jobNumber){
                                                                        
                                            int rm=currentJob.remaining[currentJob.whichBurst];
                                            
                                            model.setValueAt(currentJob.start[0],k,5);//value,row,column
                                            model.setValueAt(rm,k,6);//value,row,column
                                            
                                            if(currentJob.burst[1]==0){//if a Job has no second burst >0
                                                    if(currentJob.finished[0]==true){ //if the job has finished (since there is only burst1)                                               
                                                        int wt,tt;
                                                        tt=currentJob.finish[0]-currentJob.arrivalTime;
                                                        wt=tt-(currentJob.burst[0]);
                                                        model.setValueAt(currentJob.finish[0],k,7);//value,row,column
                                                        model.setValueAt(wt,k,8);//value,row,column
                                                        model.setValueAt(tt,k,9);//value,row,column                                            
                                                    }   
                                            }else{//if a job has burst1 and burst2
                                            
                                                    if(currentJob.finished[1]==true){ //if the job has finished burst1 and burst2                                              
                                                        int wt,tt;
                                                        tt=currentJob.finish[1]-currentJob.arrivalTime;
                                                        wt=tt-(currentJob.burst[0]+currentJob.burst[1]);
                                                        model.setValueAt(currentJob.finish[1],k,7);//value,row,column
                                                        model.setValueAt(wt,k,8);//value,row,column
                                                        model.setValueAt(tt,k,9);//value,row,column                                            
                                                    }   
                                                }
                                           
                                            break;
                                    }
                                
                                }
                                                                
                                
                        //stopping the iteration
                        if(finishedJobsList.size()==processList.size() && stopped==false){
                            cpuStatusLabel.setText("Idle");
                            runningJobLabel.setText("---");
                            
                            runButton.setEnabled(false); 
                            stopButton.setEnabled(false);            
                            restartButton.setEnabled(true);
                            
                            
                            double TT;
                            double WT;

                            double sumTT=0;
                            double sumWT=0;

                            double averageTT=0;
                            double averageWT=0;

                            /////Calculating Average Results
                            for(Job j: finishedJobsList){  
                               
                               if(j.burst[1]>0){ 
                                    TT=j.finish[1]-j.arrivalTime;
                                    sumTT+= TT;

                                    WT=TT-(j.burst[0]+j.burst[1]); 
                                    sumWT+=WT; 
                               }else{//having only burst1                                   
                                   TT=j.finish[0]-j.arrivalTime;
                                    sumTT+= TT;

                                    WT=TT-(j.burst[0]); 
                                    sumWT+=WT;                      
                               }                           
                            }  

                            averageTT=sumTT/finishedJobsList.size();
                            averageWT=sumWT/finishedJobsList.size();

                            averageWTLabel.setText(averageWT+"");
                            averageTTLabel.setText(averageTT+"");                            
                            
                            break;//stop if all jobs have finished processing               
                        } //System.out.println(finishedJobsList.size()+" = size");
                                
                        
                    } else{cpuStatusLabel.setText("Idle");}//to show when cpu is not processing any jobs at the unit times
                    
                                //execute by one second gap
                                    try
                                    {
                                        
                                        Thread.sleep(1000);
                                    }
                                    catch(InterruptedException ex)
                                    {
                                        System.out.println("Working......");
                                    }
                                    
                                    if(stopped==true){
                                        averageWTLabel.setText("N/A");
                                        averageTTLabel.setText("N/A");

                                        break;//stop if stopped button is clicked
                                    }
                    
                    }
               }
               
           
           }; t.start();          
            
            
    }                                         

    private void restartButtonActionPerformed(java.awt.event.ActionEvent evt) {                                              
        // TODO add your handling code here:
        //populateData();
       
                     
        dispose();
        RoundRobinJFrame restart=new RoundRobinJFrame();
        restart.setVisible(true);
        
    }                                             

    private void readFileButtonActionPerformed(java.awt.event.ActionEvent evt) {                                               
        // TODO add your handling code here:
        populateData();
        readFileButton.setEnabled(false);
        runButton.setEnabled(true);
    }                                              

    private void stopButtonActionPerformed(java.awt.event.ActionEvent evt) {                                           
        // TODO add your handling code here:
        
         stopped=true;
         stopButton.setEnabled(false);            
         restartButton.setEnabled(true);
         runButton.setEnabled(false);
         finishedJobsList=processList;
    }                                          

    
   
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(RoundRobinJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(RoundRobinJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(RoundRobinJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(RoundRobinJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new RoundRobinJFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify                     
    private javax.swing.JLabel averageTTLabel;
    private javax.swing.JLabel averageWTLabel;
    private javax.swing.JLabel clockLabel;
    private javax.swing.JLabel contextSwitchLabel;
    private javax.swing.JLabel cpuStatusLabel;
    private javax.swing.JLabel ganttChartLabel;
    private javax.swing.JScrollPane inputOutputScrollPane;
    private javax.swing.JLabel ioLabel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JTable jTable1;
    private javax.swing.JTable jTable3;
    private javax.swing.JTable jTable4;
    private javax.swing.JTable jobPoolTable;
    private javax.swing.JLabel numberOfJobsLabel;
    private javax.swing.JLabel quantumLabel;
    private javax.swing.JButton readFileButton;
    private javax.swing.JLabel readyQLabel;
    private javax.swing.JButton restartButton;
    private javax.swing.JButton runButton;
    private javax.swing.JLabel runningJobLabel;
    private javax.swing.JButton stopButton;
    // End of variables declaration                   
}

